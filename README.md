# DegeSharp

### How does one pronounce it?

**DegeSharp** ([degešárp])

### How does it work?

The compiler takes in a source file (*.deges*), tokenizes it, parses it and interprets it in C. The following tools were used:

- [Flex](https://gothub.dev.projectsegfau.lt/westes/flex/) - for tokenizing
- [Bison](https://www.gnu.org/software/bison/) - for parsing
- [GCC](https://gcc.gnu.org/) - for compiling the generated C code
- [Make](https://www.gnu.org/software/make/) - for building the project

### Usage

1. Clone the repository

```bash
git clone git@github.com:Pzdrs/degesharp.git
cd degesharp
```

2. Build the compiler

```bash
make build
```

3. Compile the source file

```bash
./degesharp -f <source_file>.deges
```

There are three verbosity flags:

- `--vflex` - prints the tokens generated by Flex
- `--vast` - prints traces of the parsing process and the final AST
- `--veval` - prints traces of the evaluation process (quite verbose)

#### VSCode extension (optional)

The directory `lang-server` contains a simple language server for VSCode. It provides syntax highlighting and basic autocompletion.

```bash
cd vsc-ext 
npm install
npm run full
```

## Syntax

### Variables

- Three data types: `int`, `bool`, `string`
- Decimal and hexadecimal integers

```
# Base 10 integer
-?[0-9]+
# Base 16 integer
0x[0-9a-f]+
```

- Variable declaration with/without initialization

```
jakoby : int x = 10;
jakoby : str y = "Hello world";
jakoby : bool z = true;

jakoby : int a;
jakoby : str b;
jakoby : bool c;

a = 10;
b = "Hello world";
c = true;
```

### Comparing values

```
# Analogically to C
x > y
x >= y
x < y
x <= y

# Relation == replaced by "je"
x je y
# Relation != replaced by "neni"
x neni y
```

### Arithmetic

```
# Unary operations
-y

# Binary operations
x + y;
x - y;
x * y;
x / y;
```

### String operations

```
# Concatenation
"Hello " + "world"; // "Hello world"
```

### Functions

No support for user functions, but you can use the built-in functions.

- `povidam(arg)` - prints the argument to the console (accepts `int`, `bool`, `string`)
- `print_st()` - prints the symbol table for debugging purposes

### Logical operations

```
# Conjunction (AND) replaced by "a"
# Disjunction (OR) replaced by "nebo"
# Negation (NOT) replaced by "nene"

jakoby both_positive : bool = x > 0 a y > 0;
jakoby one_positive : bool = x > 0 nebo y > 0;
jakoby positive_or_negative : bool = (x > 0 a y > 0) nebo (x < 0 a y < 0);
jakoby negation = nene positive_or_negative;
```

```
# Conditional statement

cokdyz (<condition>) {
    // do something
} [jinak] {
    // do something else
}
```

### Iteration

#### For loops

For *reasons*, the `for` loop's initialization doesn't support variable declarations, i.e. it conforms to the **C89** standard instead of C99.

```
// int initializes to 0 by default, so lets initialize it to 69 for the sake of example
jakoby i : int = 69;

loop (i = 0; i < 10; i = i + 1) {
    // do something
}

// The iteration section is optional
loop (i = 0; i < 10;) i++;

// Infinite loop
loop (;;) {
    // do something
}
```

## Things to keep in mind

- As mentioned, C89 standard is used for the `for` loop, so the initialization section doesn't support variable declarations.
- The language doesn't support floating point numbers, so the `float` and `double` types are not available.
- The internal symbol table doesn't support scoping, so all variables are global. This means that you cannot have the same variable name in different functions or blocks.